/* Atomic reference counter from Verona
 * 
 * Strong and Weak references
 *
 * Provides a wait-free acquire_strong_from_weak.
 *
 * This was verified using  ff235a5a5e0e4057 from Matt Windsor's development
 * branch of Starling.
 *    https://github.com/MattWindsor91/starling-tool
 *
 * Caveats: The proof does not contain the full lifetime management aspects 
 * such as actually running the destructor of a Cown, or deallocating the
 * underlying representation. 
 */


/**
 * The strong reference count
 */
shared int rc;

/*
 * The weak reference count
 */
shared int wrc;

/**
 * This is a mark bit added to the reference count.
 */ 
shared bool closed;


/**
 * How many threads are attempting to close the RC. This Should
 * be removed if more expressive constraints are added to Starling.
 */
shared int aux_ac;  

thread bool success;
thread bool lost_weak;
thread bool last;
thread bool more_work;

view iter StrongRef;
view iter WeakRef;
view NoStrong;
view NoWeak;

/**
 *  Represents how many threads are currently attempting to `close`
 *  the reference count as they decremented to zero.   This can be
 *  none-zero.
 */
view iter AttemptingClose;

/**
 * This corresponds to Object::incref in object.h
 */
method acquire_strong()
{
  {| StrongRef |} <| rc++; |> {| StrongRef * StrongRef |}
}

/**
 * This corresponds to Cown::weak_acquire in cown.h
 */
method acquire_weak()
{
  {| WeakRef |} <| wrc++; |> {| WeakRef * WeakRef |}
}

/**
 * This corresponds to Cown::weak_acquire in cown.h
 * It is the same method as above, just with a different specification.
 */
method acquire_weak_from_strong()
{
  {| StrongRef |} <| wrc++; |> {| StrongRef * WeakRef |}
}

/*
  This has two returns last and more_work
    If last is true, then this was decremented the final strong reference count
    If more_work is true, then the process of release this reference count resulted in
      and additional weak reference that the caller must remove.

  This corresponds to Object::decref_cown in object.h
*/
method release_strong()
{
  {| StrongRef |}
  <| rc--; last = rc==0; if last { aux_ac++; } |>
  {| if last { AttemptingClose } |}
  if last {
    {| if last { AttemptingClose } else { false } |}
    // The following is a CAS to attempt to set the bit if the 
    // rc is still zero.
    <| last = ((closed == false) && (rc == 0)); if last {closed = true;} aux_ac--; |>
    {| if last { NoStrong * WeakRef } else { WeakRef } |}
    more_work = !last;
    {| if last { NoStrong * WeakRef }
       * if more_work { WeakRef } |}
  }
  else
  {
    {| if last { NoStrong * WeakRef } |}
    more_work = false;
    {| if last { NoStrong * WeakRef }
       * if more_work { WeakRef } |}
  }
  {| if last { NoStrong * WeakRef }
    * if more_work { WeakRef } |}
}

/**
 * This is corresponds to the start of 
 * Cown::weak_release in cown.h
 * The function in Verona also handles the deallocation of
 * the underlying object, and integrating with other considerations
 * of the runtime.
 */
method release_weak()
{
  {| WeakRef |}
  <| wrc--; last = wrc == 0; |>
  {| if last { NoWeak } |}
}

/**
  This has two returns 
    success    signifies we successfully acquired a StrongRef
    more_work  signifies we lost our weak reference in the acquisition.

  This corresponds to Object::acquire_strong_from_weak in object.h
 */
method acquire_strong_from_weak()
{
  {| WeakRef |}
  <| 
     more_work = rc == 0 && !closed; 
     rc++; 
     success = !closed; 
  |>
  {| if (success) { StrongRef }
     * if (more_work) { emp } else {WeakRef}
   |}
}

// Invariant
constraint emp -> 
  rc >= 0 && 
  wrc >= 0 && 
  aux_ac >= 0 && 
  (rc > 0 => (wrc > 0 || closed == true)) &&
  ((wrc >= 1+aux_ac && rc > 0 && closed == false) 
    || (wrc >= aux_ac && (rc == 0 || closed == true)));

// Permission to run the destructor
constraint NoStrong -> closed == true;

// Permission to deallocate the underlying representation
// Would be good to prove that the rc is `closed` but that is
// not currently part of this proof.
constraint NoWeak -> wrc == 0; 

// Linear
constraint NoStrong * NoStrong -> false;
constraint NoWeak * NoWeak -> false;
constraint NoStrong * NoWeak -> false;


constraint iter[n] StrongRef -> n > 0 => (rc >= n && closed == false && n > 0);

constraint iter[n] WeakRef -> 
    ((closed == false && rc > 0 && wrc >= n + 1 + aux_ac)
     || (closed == false && rc == 0 && wrc >= n + aux_ac)
     || (closed == true && wrc >= n + aux_ac ));

// Ties auxiliary variable to how many threads are attempting to close the RC.
constraint iter[n] AttemptingClose -> aux_ac >= n; 