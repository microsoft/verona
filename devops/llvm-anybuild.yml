parameters:
  # whether to build the release configuration 
  - name: BuildRelease
    type: boolean
    default: true
  # whether to build the debug configuration
  - name: BuildDebug
    type: boolean
    default: true
  # extra command-line args to pass to AnyBuild
  - name: ExtraAnyBuildArgs
    type: string
    default: '--Epoch 1 --WhyCacheMiss --WhyCacheMissOptions CacheDataStoreKey=LLVMVerona'
  # args to pass to cmake when building
  - name: CmakeBuildToolArgs
    type: string
    default: 'install'
  # number of parallel cmake jobs
  - name: CmakeJobs
    type: number
    default: 48
  # whether to publish installed LLVM binaries as a package
  - name: PublishPackage
    type: boolean
    default: false

resources:
  repositories:
  - repository: llvm
    type: github
    endpoint: LLVMServiceConnection
    name: llvm/llvm-project
    trigger: none

jobs:
############################################# Linux Builds
- job:
  displayName: LLVM Linux Build
  pool:
    name: AnyBuild
    demands:
    - Configuration -equals $(BuildType)
  timeoutInMinutes: 120
  strategy:
    matrix:
      ${{ if eq(parameters.BuildRelease, true) }}:
        Clang Release:
          CC: clang
          CXX: clang++
          CXXFLAGS: -stdlib=libstdc++
          BuildType: Release
          BuildName: release
          Sanitizer:

      ${{ if eq(parameters.BuildDebug, true) }}:
        Clang Debug+ASAN:
          CC: clang
          CXX: clang++
          CXXFLAGS: -stdlib=libstdc++
          BuildType: Debug
          BuildName: debug
          Sanitizer: Address

  variables:
  # - name: GOOD_HASH
  #   value: Must be set in Azure DevOps
  - name: AbClientDirectory
    value: $HOME/.local/share/Microsoft/AnyBuild
  - name: AbDeploymentJson
    value: $HOME/.local/share/AnyBuildDeployment.json
  - name: AbLogsRootDir
    value: $(Build.StagingDirectory)/ab_logs
  - name: LlvmSourceDirRelativePath
    value: s
  - name: LlvmSourceDir
    value: $(Agent.BuildDirectory)/$(LlvmSourceDirRelativePath)
  - name: LlvmBuildDir
    value: $(LlvmSourceDir)/build
  - name: PKG_NAME
    value: verona-llvm-install-x86_64-linux-$(BuildName)-$(GOOD_HASH)
  - name: AbExpName
    value: LLVMVna
  - name: AbEnvironmentName
    value: LLVMVna
  - name: AbClusterId
    value: 0310c9eb-18d0-4a58-bc85-bdc02a4d764a
  - name: AnyBuildEnvironmentUri
    value: https://northeurope.anybuild-test.microsoft.com/api/clusters/$(AbClusterId)/agents
  - name: AbShimFilter
    value: '@(clang|clang++|*/clang|*/clang++|ar|*/ar|ranlib|*/ranlib|*/llvm-tblgen|*/mlir-tblgen)'

  steps:
  - checkout: llvm
    path: $(LlvmSourceDirRelativePath)

  - script: |
      set -euo pipefail
      if [[ -z $(GOOD_HASH) ]]; then
        echo "[ERROR] Variable 'GOOD_HASH' not set in Azure DevOps pipeline"
        exit 1
      fi
      git checkout $(GOOD_HASH)
    workingDirectory: $(LlvmSourceDir)
    displayName: 'Move tree to known good LLVM commit for Verona'

  - script: |
      set -euo pipefail

      sudo apt-get update
      sudo apt-get install -y clang ninja-build lld jq tree

      # Install latest CMake from snap (must first remove the pre-installed one)
      sudo apt remove -y --purge cmake
      hash -r
      sudo snap install cmake --classic 

    displayName: 'Install build dependencies'
    workingDirectory: $(Build.StagingDirectory)

  - bash: |
      set -euo pipefail

      declare AnyBuildSource=https://anybuild$(AbEnvironmentName)neurope.blob.core.windows.net/clientreleases
      declare Ring=Dogfood

      rm -rf $(AbClientDirectory)
      wget -O /tmp/bootstrapper.sh ${AnyBuildSource}/bootstrapper.sh
      chmod +x /tmp/bootstrapper.sh

      /tmp/bootstrapper.sh ${AnyBuildSource} ${Ring}

    displayName: Install AnyBuild client
    workingDirectory: $(Build.StagingDirectory)

  - bash: |
      function log-and-run {
        echo "Running "
        echo "  CWD = $(pwd)"
        echo "  CMD = $@"
        "$@"
      }

      rm -rf "$(LlvmBuildDir)"
      mkdir -p "$(LlvmBuildDir)"
      cd "$(LlvmBuildDir)"
      log-and-run cmake $(LlvmSourceDir)/llvm -GNinja -DCMAKE_BUILD_TYPE=$(BuildType) -DCMAKE_C_COMPILER=$(CC) -DCMAKE_CXX_COMPILER=$(CXX) -DCMAKE_CXX_FLAGS=$(CXXFLAGS) -DLLVM_USE_SANITIZER=$(Sanitizer) -DLLVM_ENABLE_PROJECTS="clang;mlir" -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_ENABLE_LLD=ON -DLLVM_ENABLE_EH=ON -DLLVM_ENABLE_RTTI=ON -DCMAKE_INSTALL_PREFIX=install -DMLIR_INCLUDE_TESTS=OFF
    displayName: 'CMake'

  - bash: |
      function extract_logs {
        local buildDir="$1"
        local logsDir="$2"

        echo 
        echo "====== Extracting logs from '${buildDir}' into '${logsDir}'"
        echo

        rm -rf "$logsDir"
        mkdir "$logsDir"
        mv "$buildDir"/*log "$logsDir"
      }

      function build {
        local time_limit="$1"

        if [[ -z "$(AbExpName)" ]]; then
          echo "ERROR: Variable 'AbExpName' not set"
          return 1
        fi

        if [[ -z "${{ parameters.CmakeJobs }}" ]]; then
          echo "ERROR: Variable 'CmakeJobs' not set"
          return 1
        fi

        echo
        echo "===== Running build (${{ parameters.CmakeJobs }} CMake jobs) up to ${time_limit} from $(pwd)"
        echo

        env -i \
          llvmPassword=$(LLVMPrincipalPassword) \
          HOME="$HOME" \
          PATH="$PATH" \
        timeout "$time_limit" time $(AbClientDirectory)/AnyBuild.sh \
          --RemoteExecServiceUri $(AnyBuildEnvironmentUri) \
          --NoCheckForUpdates \
          --WaitForAgentForever \
          --DoNotUseMachineUtilizationForScheduling \
          --Verbose \
          --RemoteAll \
          --ClientApplicationId $(LLVMPrincipalAppId) \
          --ClientSecretEnvironmentVariable llvmPassword \
          --ShimProcessFilter '$(AbShimFilter)' \
          ${{ parameters.ExtraAnyBuildArgs }} \
          -- \
          $(which cmake) --build . -- -j ${{ parameters.CmakeJobs }} ${{ parameters.CmakeBuildToolArgs }}
      }

      declare failed=0
      build 90m || failed=$?

      extract_logs "$(pwd)" "$(AbLogsRootDir)"

      exit $failed

    workingDirectory: $(LlvmBuildDir)
    displayName: Build LLVM with AnyBuild

  - bash: |
      set -euo pipefail
      cd "$(LlvmBuildDir)"
      ninja clean
    condition: and(succeeded(), eq(${{ parameters.PublishPackage }}, true))
    displayName: Delete build outputs to free up space for 'Create package'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Artifact: Logs'
    inputs:
      PathToPublish: $(AbLogsRootDir)
      ArtifactName: Logs_$(BuildName)
    continueOnError: true
    condition: always()

  - bash: |
      set -euo pipefail

      for abLogFile in $(find "$(AbLogsRootDir)" -name AnyBuild.log); do
          echo "=== $abLogFile ==="
          sed -n '/Session telemetry: Finished/,$ p' "$abLogFile"
          echo
      done

    workingDirectory: $(LlvmBuildDir)
    continueOnError: true
    condition: always()
    displayName: Print out AnyBuild stats

  - bash: |
      set -euo pipefail
      rm -f $(PKG_NAME).tar
      tar --sort=name --owner=root:0 --group=root:0 --mtime='UTC 2021-01-01' -cf $(PKG_NAME).tar build/install
      md5sum $(PKG_NAME).tar | awk '{print $1}' > $(PKG_NAME).tar.md5
      rm -rf "$(PKG_NAME)"
      mkdir $(PKG_NAME)
      mv "$(PKG_NAME).tar" "$(PKG_NAME)/"
      mv "$(PKG_NAME).tar.md5" "$(PKG_NAME)/"
      echo "Created '$(PKG_NAME).tar'"
      ls -l "$(PKG_NAME)/"
      cat "$(PKG_NAME)/$(PKG_NAME).tar.md5"
    continueOnError: false
    condition: and(succeeded(), eq(${{ parameters.PublishPackage }}, true))
    displayName: Create package

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Artifact: Package'
    condition: and(succeeded(), eq(${{ parameters.PublishPackage }}, true))
    inputs:
      PathToPublish: $(PKG_NAME)
      ArtifactName: $(PKG_NAME)

  - script: |
      set -euo pipefail
      echo "Deleting $(LlvmBuildDir)"
      rm -rf "$(LlvmBuildDir)"

      echo "Deleting $(PKG_NAME)"
      rm -rf "$(PKG_NAME)"
    continueOnError: false
    displayName: 'Clean'
