# Verona MLIR Generator Design Choices

The MLIR generator sits in between the AST and LLVM IR, and is meant to ease lowering while still maintaining some high level concepts to allow us to optimise the code with Verona-specific semantics before we lower to LLVM IR and lose information.

Verona needs to know the type constraints of objects (imm, mut, iso) as well as which region they belong to and if those regions have the same sentinel object.

For those reasons, Verona will need a light dialect to represent type constraints, region information and module boundaries, which don't naturally convert to LLVM IR.

## Generation Simplicity

The new AST is much simpler than the previous.
The new parser uses a lean typed AST and converts all language into those nodes, which becomes much simpler to lower to an IR.
The parser also runs the type checks and inference, so the AST we get at this stage is already complete (explicit concrete monomorphic types, reified code only), and checked for syntactic and semantic errors.

If an error is detected when generating MLIR, however, we still have the original source locations and can return the errors to the parser's own diagnostics infrastructure.

The MLIR dialect that we'll develop at this stage will be solely for representing the lowering concepts in order to simplify high-level optimisations before lowering to LLVM IR.
In theory, the AST could have been directly lowered to LLVM IR, but the LLVM pipeline wouldn't be able, for example, to optimise based on type and region information, memory management mechanisms (ex. ref count), object layout and representation, etc.

## Load/Store Semantics

Stack variables are allocated by LLVM IR with an `alloca` instruction.
MLIR doesn't support allocating stack memory with anything other than `memref` types, but it does support the LLVM dialect, which has full LLVM semantics.
In this preliminary implementation, we use the LLVM dialect for alloca/load/store/GEP operations when dealing with stack objects.
This approach seems very clean and sensible, and it could be used for accessing heap variables as well.

For now, every function argument and local declaration (`let`, `var`) are allocated in the stack and its value stored there.
This simplifies code generation (all variable symbols point to an address), but it doesn't help with value symbols and are really slow.

The LLVM pipeline, even at O1, recognises most of the argument, temporary and local allocas as bogus and optimises them away, so this isn't an immediately critical issue from a performance point of view, but we will want to clean up some of those repetitive patterns soon enough.

## Runtime Calls

The Verona runtime is where the magic happens.
Allocating regions, choosing the memory management strategy, scheduling behaviours, dispatching foreign language code, etc.
The AST, however, has only the semantics of the language (with hints to the runtime behaviour), so we need to translate it at the MLIR lowering level.

For example, heap allocation, which LLVM IR generally uses calls to `@llvm.malloc`, Verona uses `snmalloc`, which has a finer control over what we can do with the regions.
In the end, however, it will be the same: calls to the runtime library in IR.

The generator knows what runtime calls are appropriate for each AST construct, and can insert those calls in the right places and make sure to declare the methods so that linking with the runtime library works.

## Arithmetic

Arithmetic is generated by the generator via pattern matching on the types and selectors.
Adding two numbers (`a + b`) is the same as calling the method `+` on `a` over `b` (`a.+(b)`), but these methods don't exist (how would we implement addition if not with a `+`?).

So the generator has to find those that weren't declared and replace with arithmetic if the types are compatible (int, float).

Users are still allowed to use `+` as a method name, in which case the generator will recognise and call that method instead of transforming into arithmetic, even if the types are compatible.
For example:

```
// Verona code
class U32 {}
class Foo {
  static +(a: U32, b: U32) { ... }
}
main() : U32 {
  let a = 21 + 21; // This is simple arithmetic
  let b = Foo::+(21, 21); // This calls the method
}
```

## Type Constraints

TODO

## Region Information

TODO
