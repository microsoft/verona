# This is not (yet) a full grammar. The parser is not auto-generated from this
# grammar.

# Precedence:
# 1. postfix
# 2. prefix
# 3. infix
# 4. assign

tupletype <- '(' (type (',' type)*)? ')'
typeref <- ident typeargs? ('::' ident typeargs?)*
viewtype <- (typeref ('~>' / '<~'))* (typeref / tupletype)
functiontype <- viewtype ('->' functiontype)?
isecttype <- functiontype ('&' functiontype)*
uniontype <- isecttype ('|' isecttype)*
type <- uniontype

declelem <- ref / '(' declelem (',' declelem)* ')' oftype?
decl <- ('let' / 'var') declelem
new <- 'new' (tuple / type? typebody) ('in' ident)?
# TODO: this is wrong, can have typeparams
staticref <- ident ('::' ident)* ('::' (ident / sym))
ref <- ident oftype?
symref <- sym

stringlit <- escapedstring / unescapedstring
string <- stringlit (localref / tuple / stringlit)*
constant <- character / float / int / hex / binary / 'true' / 'false'
atom <- staticref / ref / symref / constant / string / new / decl / tuple

case <- expr ('if' expr)? '=>' expr

for <- 'for' '(' expr 'in' expr ')' block
while <- 'while' tuple block
if <- 'if' tuple block ('else' block)?
match <- 'match' tuple '{' case* '}'
when <- 'when' tuple block
lambda <- (signature / ident) '=>' expr
block <- '{' ('}' / (inblock / expr ';')* controlflow? '}')
blockexpr <- block / when / match / if / while / for / try / lambda

controlflow <- 'break' / 'continue' / 'return' expr? / 'yield' expr? / expr
typeargs <- '[' expr (',' expr)* ']'
tuple <- '(' expr (',' expr)* ')' oftype?

op <- nonlocalref / symref
postfix <- atom (dot (sym / ident) / typeargs / tuple)*
prefix <- op prefix / postfix
preblock <- op preblock / blockexpr
infix <- prefix (op prefix)*
inblock <- preblock / infix (op preblock)?

expr <- inblock / infix ('=' expr)

param <- ident oftype? initexpr?
params <- '(' param* ')'
throws <- 'throws' type
signature <- typeparams? params oftype? throws? constraint*

initexpr <- '=' expr
inittype <- '=' type
oftype <- ':' type
constraint <- 'where' ident oftype? inittype?
typeparams <- '[' ident (',' ident)* ']'
typebody <- '{' member* '}'

field <- ident oftype? initexpr? ';'
function <- 'static' signature (block / ';')
method <- signature (block / ';')
member <- module / class / interface / typealias / field / function / method

entity <- typeparams? oftype? constraint*
namedentity <- ident entity

typealias <- 'type' namedentity '=' type ';'
interface <- 'interface' namedentity typebody
class <- 'class' namedentity typebody
module <- 'module' entity ';'

escape <- '\\' ('"' / '\'' / ...)
escapedstring <- '"' (escape / !'"' .)* '"'
unescapedstring <- '\'[n]"' (unescapedstring[n] / !('"\'[n]') .)* '"\'[n]'
character <- '\'' (!'\'' .)* '\''
