// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/**
 * This file contains the start of the standard library. It is just enough to 
 * get a few examples working.
 * 
 * Nothing in here is expected to remain long-term without significant change.
 **/

class Builtin {
  // Selection of print functions that simply pass to the underlying C++
  // formatter.  This is a hack to get some examples with output until we have 
  // implemented IO.
  builtin print(format: String);
  builtin print1[T0](format: String, arg0: T0);
  builtin print2[T0, T1](format: String, arg0: T0, arg1: T1);
  builtin print3[T0, T1, T2](format: String, arg0: T0, arg1: T1, arg2: T2);
  builtin print4[T0, T1, T2, T3](format: String, arg0: T0, arg1: T1, arg2: T2, arg3: T3);
  builtin print5[T0, T1, T2, T3, T4](format: String, arg0: T0, arg1: T1, arg2: T2, arg3: T3, arg4: T4);

  // Freeze an isolated object graph
  builtin freeze[class T](x: T & iso): T & imm;

  // This exposes trace on a traceable region
  // TODO: invalidate other references into this region
  // TODO: needs expanding as we add other region allocation strategies
  builtin trace(x : mut);

  // Print the given message and abort execution.
  builtin error[T](reason: String): T;
}

/**
 * Simple None class that is used in examples.
 **/
class None {
  create(): None & imm {
    Builtin.freeze (new None)
  }
}

/**
 * Class for boxing a U64. Useful until we have property support for primitives
 * in all the correct places.
 **/
class U64Obj
{
  v: U64 & imm;
  create(x: U64 & imm) : U64Obj & iso
  {
    var o = new U64Obj;
    o.v = x;
    o
  }

  print(p : U64Obj & mut)
  {
    Builtin.print1("{}\n", p.v);
  }
}

primitive cown[class T] {
  builtin create(value: T & iso): cown[T] & imm;

  // Temporary API to implement promises
  // This should not be used outside the standard library.
  builtin _create_sleeping(): cown[T] & imm;
  builtin _fulfill_sleeping(self: imm, v: T & iso);
}

/**
 * This is the implementation of promises. It should be surfaced more nicely to
 * the programmer, but is type safe.
 **/ 
class Promise[class T]
{
  inner_cown: cown[T] & imm;

  create(): Promise[T] & iso
  { 
    var p = new Promise;
    p.inner_cown = cown._create_sleeping();
    p
  } 

  wait_handle(self: mut): cown[T] & imm
  { 
    self.inner_cown
  }

  fulfill(self: iso, v: T & iso)
  { 
    (self.inner_cown)._fulfill_sleeping(v); 
  }
}

primitive U64 {
  builtin add(self: imm, other: U64 & imm): U64 & imm;
  builtin sub(self: imm, other: U64 & imm): U64 & imm;
  builtin mul(self: imm, other: U64 & imm): U64 & imm;
  builtin div(self: imm, other: U64 & imm): U64 & imm;
  builtin mod(self: imm, other: U64 & imm): U64 & imm;
  builtin shl(self: imm, other: U64 & imm): U64 & imm;
  builtin shr(self: imm, other: U64 & imm): U64 & imm;
  builtin lt(self: imm, other: U64 & imm): U64 & imm;
  builtin gt(self: imm, other: U64 & imm): U64 & imm;
  builtin le(self: imm, other: U64 & imm): U64 & imm;
  builtin ge(self: imm, other: U64 & imm): U64 & imm;
  builtin eq(self: imm, other: U64 & imm): U64 & imm;
  builtin ne(self: imm, other: U64 & imm): U64 & imm;
  builtin and(self: imm, other: U64 & imm): U64 & imm;
  builtin or(self: imm, other: U64 & imm): U64 & imm;
}

/**
 * Manually managed array of values.
 *
 * This API is unsafe, and should only be used to implement Array.
 *
 * The elements stored through the pointer are not traced automatically. They
 * should instead be traced through some other mean. For example, the trace
 * function of Array is special cased to cover its backing array.
 */
primitive Pointer[T] {
  /**
   * Allocate a block of memory.
   *
   * The size is specified in number of elements, not in bytes.
   */
  builtin allocate(size: U64 & imm): Pointer[T] & imm;

  /**
   * Free a block of memory.
   *
   * The size argument must match the size that was used during allocation.
   * All elements in the allocation must be uninitialized.
   */
  builtin free(ptr: Pointer[T] & imm, size: U64);

  /**
   * Get the element at the given index.
   *
   * The parent argument is used to apply region information and viewpoint
   * adaptation.
   */
  builtin get(parent: (mut | imm), ptr: Pointer[T] & imm, index: U64 & imm): T
    where return in parent;

  /**
   * Set the value at a given index. That location must be uninitialized prior
   * to calling this function. If it is initialized, then the swap method should
   * be used instead to ensure the old value is collected correctly.
   *
   * The parent argument is used to apply region information and to access the
   * remembered set in case a reference counted value is written.
   */
  builtin set(parent: mut, ptr: Pointer[T] & imm, index: U64 & imm, value: T)
    where value in parent;

  /**
   * Replace the value at a given index.
   *
   * The parent argument is used to apply region information and to access the
   * remembered set in case a reference counted value is written.
   */
  builtin swap(parent: mut, ptr: Pointer[T] & imm, index: U64 & imm, value: T): T
    where value in parent, return from parent;

  /**
   * Move a set of values from one allocation to another. The memory locations
   * in the destination array must be uninitialized. The locations in the source
   * array will be uninitialized after this method is called.
   */
  builtin move(parent: mut, src: Pointer[T] & imm, dst: Pointer[T] & imm, size: U64 & imm);
}

